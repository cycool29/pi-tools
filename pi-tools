#!/usr/bin/env bash
# shellcheck disable=SC2155,SC2094,SC2034,SC2059

# trap functions
set -E

export DIRECTORY="$(dirname "$(readlink -f "$0")")"

# check if this script is running through a pipe or being redirected
if ! [ -t 1 ] || ! [ -t 2 ]; then 
	PIPED="1"
fi

question() {
	echo -e "${YELLOW}${BOLD}[?]${NORMAL} ${LIGHT_YELLOW}$1${NORMAL}" 
}

status() { 
	echo -e "${CYAN}${BOLD}[-]${NORMAL} ${LIGHT_CYAN}$1${NORMAL}" 
}

status_bold() { 
	echo -e "${CYAN}${BOLD}[-]${NORMAL} ${LIGHT_CYAN}${BOLD}$1${NORMAL}" 
}

success() { 
	echo -e "${GREEN}${BOLD}[✔]${NORMAL} ${LIGHT_GREEN}$1${NORMAL}" 
}

success_bold() {
	echo -e "${GREEN}${BOLD}[✔]${NORMAL} ${LIGHT_GREEN}${BOLD}$1${NORMAL}"
}

pi-tools_help_ERROR_MESSAGE() {
	echo "╱╱╱╱╱╱╱╭╮╱╱╱╱╱╱╭╮
╱╱╱╱╱╱╭╯╰╮╱╱╱╱╱┃┃
╭━━┳╮╱╰╮╭╋━━┳━━┫┃╭━━╮
┃╭╮┣╋━━┫┃┃╭╮┃╭╮┃┃┃━━┫
┃╰╯┃┣━━┫╰┫╰╯┃╰╯┃╰╋━━┃
┃╭━┻╯╱╱╰━┻━━┻━━┻━┻━━╯
┃┃
╰╯"
	echo "pi-tools (pt) 1.0 on Raspberry Pi ${PI_VERSION}, $(dpkg --print-architecture)"
	echo "Installed at ${DIRECTORY}."
	echo
	echo "pi-tools is a command-line tool to access almost all settings, functions, etc, of your Raspberry Pi."
   
}

is_empty() {
    local TARGET="${1}"

    [[ -z "${TARGET}" ]]
}

is_not_empty() {
    local TARGET="${1}"

    [[ -n "${TARGET}" ]]
}

is_file() {
    local TARGET="${1}"

    [[ -f "${TARGET}" ]]
}

is_dir() {
    local TARGET="${1}"

    [[ -d "${TARGET}" ]]
}

is_number() {
    local TARGET="${1}"

		[[ "${TARGET}" =~ ^[0-9]+$ ]]
}

sudo_password() {
	if ! sudo -n ls &>/dev/null; then 
		status "This operation needs root access."
		sudo -S true || error "Authentication Failed." 
		success "Root authentication success."
	fi
}

get_pi_version() {
	if grep -q "^Revision\s*:\s*00[0-9a-fA-F][0-9a-fA-F]$" /proc/cpuinfo || grep -q "^Revision\s*:\s*[ 123][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]0[0-36][0-9a-fA-F]$" /proc/cpuinfo ; then
		PI_VERSION=1
	elif grep -q "^Revision\s*:\s*[ 123][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]04[0-9a-fA-F]$" /proc/cpuinfo; then
		PI_VERSION=2
	elif grep -q "^Revision\s*:\s*[ 123][0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]0[9cC][0-9a-fA-F]$" /proc/cpuinfo; then
		PI_VERSION=3
	elif grep -q "^Revision\s*:\s*[ 123][0-9a-fA-F][0-9a-fA-F]3[0-9a-fA-F][0-9a-fA-F][0-9a-fA-F]$" /proc/cpuinfo; then
		PI_VERSION=4
	else
		error "Raspberry Pi version not detected.\nIf you are using a Raspberry Pi 1, 2, 3 or 4, PLEASE report to https://github.com/cycool29/pi-tools/issue."
	fi
	[ "${NOT_SOURCED}" == 1 ] && echo "${PI_VERSION}"
}

get_codename() {
    lsb_release -sc
}

check_internet() {
	ping -q -c1 example.com &>/dev/null 
	return $?
}

install_pi-tools_dependencies() {
	sudo_password || exit 1
	# shellcheck disable=2046
	(sudo apt-get update --allow-releaseinfo-change 2>&1 && sudo apt-get install -qq --no-install-recommends $(cat "${DIRECTORY}/files/dependencies")) || error "Failed to install pi-tools dependencies."
}

prepare() {
	while read -r i; do
		if ! dpkg -s "$i" &>/dev/null ; then
			install_pi-tools_dependencies || exit 1
			break
		fi
	done <"${DIRECTORY}/files/dependencies"

	chmod +x "${DIRECTORY}"/scripts/*
}


scan_bluetooth() { # scan bluetooth devices, the only 1 accepted is the timeout duration
	TIMEOUT_DURATION="${1}"
	bluetoothctl --timeout "${TIMEOUT_DURATION}" scan on
}

detect_device_type() {
	TARGET="${1}"
	if [[ "${TARGET}" =~ ^([a-fA-F0-9]{2}:){5}[a-fA-F0-9]{2}$ ]]; then
		echo "MAC Address"
	else 
		echo "Device Name" 
	fi
}

turn_bluetooth() {
	case ${1} in 
		on)
			status "Turning on Bluetooth..."
			sudo_password || exit 1
			sudo rfkill unblock bluetooth || error "Failed to turn on Bluetooth."
			sudo service bluetooth restart 
			bluetoothctl power on
		;;
		off)
			status "Turning off Bluetooth..."
			sudo_password || exit 1
			sudo rfkill block bluetooth || error "Failed to turn off Bluetooth."
		;;
		restart)
			status "Restarting Bluetooth"
			sudo_password || exit 1
			sudo rfkill block bluetooth || error "Failed to turn off Bluetooth."
			sudo rfkill unblock bluetooth || error "Failed to turn on Bluetooth."
		;;
	esac
}

find_root_partition() {
	sudo findmnt / -o source -n
}

find_root_device(){
	local ROOT_PARTITION="${1}"
	echo "/dev/$(sudo lsblk -no pkname "${ROOT_PARTITION}")"
}

find_root_partition_number() {
	local ROOT_PARTITION="${1}"
	grep -o "[[:digit:]]*$" <<<"${ROOT_PARTITION}"
}

find_last_root_partition_number(){
	local ROOT_DEVICE="${1}"
	sudo parted "${ROOT_DEVICE}" -ms unit s p | tail -n 1 | cut -f 1 -d:
}

find_partition_start_offset(){
	local ROOT_DEVICE="${1}"
	local PARTITION_NUMBER="${2}"
	local PARTITION_START="$(sudo parted "${ROOT_DEVICE}" -ms unit s p | grep "^${PARTITION_NUMBER}" | cut -f 2 -d: | sed 's/[^0-9]//g')"
	if is_empty "${PARTITION_START}"; then
		return 1
	else
		echo "${PARTITION_START}"
	fi
}

update_apps() {
	sudo_password
	status_bold "Updating APT"
	status "Updating APT package list..."
	OUTPUT="$(sudo apt update --allow-releaseinfo-change 2>&1)" || error "Failed to update APT package list.:\n${OUTPUT}"
	if echo "$OUTPUT" | grep -q "All packages are up to date"; then
		success "All APT packages are up to date." 
	elif echo "$OUTPUT" | grep -q 'can be upgraded'; then
		echo "$OUTPUT" | grep 'can be upgraded' --color=None | sed "s/Run 'apt list --upgradable' to see it.//g"
	else 
		error "pi-tools failed to parse APT output:\n$OUTPUT" 
		
	fi
	success_bold "Done"
}

set_keyboard() {
	status_bold "Configuring keyboard"
	sudo_password
	status "Please select the keymap of the keyboard."
	KEYMAP_CHOICE="$(cut -c23- < "${DIRECTORY}/files/keymaps" | fzf --height 20 --cycle)" # user choice
	KEYMAP_CHOICE="$(grep "${KEYMAP_CHOICE}" < "${DIRECTORY}/files/keymaps" | cut -c1-22 | x1s)" # filter the choice
	sudo -E sed -i /etc/default/keyboard -e "s/^XKBLAYOUT.*/XKBLAYOUT=\"${KEYMAP_CHOICE}\"/"
	status "Configuring keyboard-configuration..."
	sudo -E dpkg-reconfigure -f noninteractive keyboard-configuration 2>&1 
	status "Enabling keyboard-setup initscript..."
	sudo -E invoke-rc.d keyboard-setup start
	status "Setting up keyboard..."
	sudo -E setsid sh -c 'exec setupcon -k --force <> /dev/tty1 >&0 2>&1' 
	sudo -E udevadm trigger --subsystem-match=input --action=change
	success_bold "Done"
}

is_installed() {
  if [ "$(dpkg -l "$1" 2> /dev/null | tail -n 1 | cut -d ' ' -f 1)" != "ii" ]; then
    return 1
  else
    return 0
  fi
}

get_device_info(){

	DPKG_PACKAGES="$(dpkg --get-selections | grep -vc deinstall)"

	command -v snap &>/dev/null && ! snap list 2>&1 \
		| grep -q "No snaps are installed" \
		&& SNAP_PACKAGES="$(snap list | tail -n +2 | wc -l)"

	command -v flatpak &>/dev/null \
		&& if flatpak info 2>/dev/null | grep -q "Note that the directories"; then 
			export XDG_DATA_DIRS="$XDG_DATA_DIRS:$(flatpak info 2>/dev/null | tail -n +4 | head -n 2 | x1s | sed 's/ /:/g')"
		fi && [ "$(flatpak list)" != "" ] && FLATPAK_PACKAGES="$(flatpak list | grep -vc 'Application ID')"
	
	OS="$(grep PRETTY_NAME  < /etc/os-release | tr -d '"' | awk -F= '{print $2}')" 
	OS_ARCH="$(dpkg --print-architecture)" 
	KERNEL="$(uname -mrs)" 
	MODEL="$(grep Model  < /proc/cpuinfo | x1s | sed 's/Model : //g')" 
	RAM_SIZE="$(echo "scale=2 ; $( awk '/MemTotal/ {print $2}' /proc/meminfo ) / 1024000 " | bc ) GB"
	IMAGE_VERSION="$(grep 'Raspberry Pi reference'  < /etc/rpi-issue | sed 's/Raspberry Pi reference //g')" 
	INSTALLED_PACKAGES="dpkg (${DPKG_PACKAGES})$(is_not_empty "${SNAP_PACKAGES}" && echo ", snap (${SNAP_PACKAGES})")$(is_not_empty "${FLATPAK_PACKAGES}" && echo ", flatpak (${FLATPAK_PACKAGES})")"
	UPTIME="$(uptime -p | sed "s/up //g" | sed s/,//g)" 
	RESOLUTION="$(fbset -i  | grep "mode " | tr -d '"' | tr -d "mode ")" 
	DESKTOP_ENVIRONMENT="$XDG_CURRENT_DESKTOP" 
	WINDOW_MANAGER="$(xprop -id "$(xprop -root -notype _NET_SUPPORTING_WM_CHECK | sed 's/.*# //')" -notype -len 100 -f _NET_WM_NAME 8t | grep WM_NAME | sed 's/.*= //g' | x1s)" 
	OPENGL_VERSION="$(glxinfo -B | grep 'OpenGL ES profile version string' | sed 's/OpenGL ES profile version string: //g')"
	GPU_MODEL="$(glxinfo -B | grep 'Device\|Vendor' | sed 's/.*Device: //g' | sed 's/.*Vendor: //g' | sed -e 's/([^()]*)//g' | x1s)"
	HOSTNAME="$(hostname)"
	LOCAL_IP="$(hostname -I | awk '{print $1}')"
	PUBLIC_IP="$(wget -qO- ifconfig.me)"
	CURRENT_USER="$(whoami)"
	SOC_VERSION="$(grep Hardware < /proc/cpuinfo | cut -c12-18)"
	# shellcheck disable=SC2001
	GPU_TEMPERATURE="$(sed s/temp=//g <<< "$(vcgencmd measure_temp)")"
	CPU_MODEL="$(lscpu | grep "Model name\|Vendor ID" | sed 's/.*://g' | x1s)"

	echo -e "${GREEN}Operating System   ${NORMAL} : $(if is_empty "${OS}"; then echo -e "${DARK_GREY}Not available${NORMAL}"; else echo "${OS}"; fi)"
	echo -e "${GREEN}OS Architecture    ${NORMAL} : $(if is_empty "${OS_ARCH}"; then echo -e "${DARK_GREY}Not available${NORMAL}"; else echo "${OS_ARCH}"; fi)"
	echo -e "${GREEN}Kernel             ${NORMAL} : $(if is_empty "${KERNEL}"; then echo -e "${DARK_GREY}Not available${NORMAL}"; else echo "${KERNEL}"; fi)"
	echo -e "${GREEN}Raspberry Pi Model ${NORMAL} : $(if is_empty "${MODEL}"; then echo -e "${DARK_GREY}Not available${NORMAL}"; else echo "${MODEL}"; fi)"
	echo -e "${GREEN}RAM Size           ${NORMAL} : $(if is_empty "${RAM_SIZE}"; then echo -e "${DARK_GREY}Not available${NORMAL}"; else echo "${RAM_SIZE}"; fi)"
	echo -e "${GREEN}Image Version      ${NORMAL} : $(if is_empty "${IMAGE_VERSION}"; then echo -e "${DARK_GREY}Not available${NORMAL}"; else echo "${IMAGE_VERSION}"; fi)"
	echo -e "${GREEN}Installed Packages ${NORMAL} : $(if is_empty "${INSTALLED_PACKAGES}"; then echo -e "${DARK_GREY}Not available${NORMAL}"; else echo "${INSTALLED_PACKAGES}"; fi)"
	echo -e "${GREEN}Uptime             ${NORMAL} : $(if is_empty "${UPTIME}"; then echo -e "${DARK_GREY}Not available${NORMAL}"; else echo "${UPTIME}"; fi)"
	echo -e "${GREEN}Resolution         ${NORMAL} : $(if is_empty "${RESOLUTION}"; then echo -e "${DARK_GREY}Not available${NORMAL}"; else echo "${RESOLUTION}"; fi)"
	echo -e "${GREEN}Desktop Environment${NORMAL} : $(if is_empty "${DESKTOP_ENVIRONMENT}"; then echo -e "${DARK_GREY}Not available${NORMAL}"; else echo "${DESKTOP_ENVIRONMENT}"; fi)"
	echo -e "${GREEN}Window Manager     ${NORMAL} : $(if is_empty "${WINDOW_MANAGER}"; then echo -e "${DARK_GREY}Not available${NORMAL}"; else echo "${WINDOW_MANAGER}"; fi)"
	echo -e "${GREEN}OpenGL Version     ${NORMAL} : $(if is_empty "${OPENGL_VERSION}"; then echo -e "${DARK_GREY}Not available${NORMAL}"; else echo "${OPENGL_VERSION}"; fi)"
	echo -e "${GREEN}GPU Model          ${NORMAL} : $(if is_empty "${GPU_MODEL}"; then echo -e "${DARK_GREY}Not available${NORMAL}"; else echo "${GPU_MODEL}"; fi)"
	echo -e "${GREEN}Local IP Address   ${NORMAL} : $(if is_empty "${LOCAL_IP}"; then echo -e "${DARK_GREY}Not available${NORMAL}"; else echo "${LOCAL_IP}"; fi)"
	echo -e "${GREEN}Public IP Address  ${NORMAL} : $(if is_empty "${PUBLIC_IP}"; then echo -e "${DARK_GREY}Not available${NORMAL}"; else echo "${PUBLIC_IP}"; fi)"
	echo -e "${GREEN}Current User       ${NORMAL} : $(if is_empty "${CURRENT_USER}"; then echo -e "${DARK_GREY}Not available${NORMAL}"; else echo "${CURRENT_USER}"; fi)"
	echo -e "${GREEN}SoC Version        ${NORMAL} : $(if is_empty "${SOC_VERSION}"; then echo -e "${DARK_GREY}Not available${NORMAL}"; else echo "${SOC_VERSION}"; fi)"	
	echo -e "${GREEN}GPU Temperature    ${NORMAL} : $(if is_empty "${GPU_TEMPERATURE}"; then echo -e "${DARK_GREY}Not available${NORMAL}"; else echo "${GPU_TEMPERATURE}"; fi)"	
	echo -e "${GREEN}CPU Model          ${NORMAL} : $(if is_empty "${CPU_MODEL}"; then echo -e "${DARK_GREY}Not available${NORMAL}"; else echo "${CPU_MODEL}"; fi)"	
}

testfunc() {
	ech wowowo
}


error() {
	echo -e "${RED}${BOLD}[!]${NORMAL} ${LIGHT_RED}${UNDERLINE}ERROR${NORMAL}" 1>&2
  local LINE_INDICATES_ERROR="$1"
	shift
	while [ "${1}" ]; do
		if echo "${1}"| grep -q ' '; then
	 	 local ERROR_MESSAGE="${1}" # there is space in $1, assume error message
		elif is_number "${1}"; then
			local EXIT_CODE="${1}" # $1 is a number, assume exit code
		else
			local FUNCTION_NAME="${1}" # no space and not number in $1, assume function name
		fi
	shift
	done
  local EXIT_CODE="${EXIT_CODE:-1}" # if no exit code specified, fall back to 1

	echo "    Near line ${LINE_INDICATES_ERROR}." 1>&2
	is_not_empty "${FUNCTION_NAME}" && echo "    At Function: ${FUNCTION_NAME}" 1>&2
	is_not_empty "${ERROR_MESSAGE}" && echo "    Error Message: ${ERROR_MESSAGE}" 1>&2
	echo "    Exit code: ${EXIT_CODE}" 1>&2

  exit "${EXIT_CODE}"
}

trap 'echo ${FUNCNAME}; error ${LINENO} ${FUNCNAME}' ERR
trap 'echo -e "${RED}${BOLD}[!]${NORMAL} ${LIGHT_RED}${UNDERLINE}CTRL-C detected. Exiting now.${NORMAL}" 1>&2; exit 1' INT


if ! [ -t 1 ] || ! [ -t 2 ]; then
	PIPED=1
fi


#text formatting variables
text_format() {
	RED="$(if is_empty ${PIPED}; then echo '\e[31m'; else true; fi)"
	GREEN="$(if is_empty ${PIPED}; then echo '\e[32m'; else true; fi)"
	YELLOW="$(if is_empty ${PIPED}; then echo '\e[33m'; else true; fi)"
	BLUE="$(if is_empty ${PIPED}; then echo '\e[34m'; else true; fi)"
	CYAN="$(if is_empty ${PIPED}; then echo '\e[36m'; else true; fi)"
	LIGHT_RED="$(if is_empty ${PIPED}; then echo '\e[91m'; else true; fi)"
	LIGHT_GREEN="$(if is_empty ${PIPED}; then echo '\e[92m'; else true; fi)"
	LIGHT_YELLOW="$(if is_empty ${PIPED}; then echo '\e[93m'; else true; fi)"
	LIGHT_BLUE="$(if is_empty ${PIPED}; then echo '\e[94m'; else true; fi)"
	LIGHT_CYAN="$(if is_empty ${PIPED}; then echo '\e[96m'; else true; fi)"
	WHITE="$(if is_empty ${PIPED}; then echo '\e[97m'; else true; fi)"
	DARK_GREY="$(if is_empty ${PIPED}; then echo '\e[90m'; else true; fi)"
	BOLD="$(if is_empty ${PIPED}; then echo '\e[1m'; else true; fi)"
	UNDERLINE="$(if is_empty ${PIPED}; then echo '\e[4m'; else true; fi)"
	INVERTED="$(if is_empty ${PIPED}; then echo '\e[7m'; else true; fi)"
	NORMAL="$(if is_empty ${PIPED}; then echo '\e[0m'; else true; fi)"
	DIM="$(if is_empty ${PIPED}; then echo '\e[2m'; else true; fi)"
}

text_format
testfunc || error "${LINENO}" "Failed to run testfunc"

# set_keyboard
# case $1 in
# 	-h|--help)
# 		show_help_ERROR_MESSAGE
# 	;;
# 	di|device-info)
# 		shift
# 		"${DIRECTORY}/scripts/get-device-info" || exit 1
# 	;;
# 	bt|bluetooth)
# 		shift
# 		"${DIRECTORY}/scripts/bluetooth" "$@" || exit 1
# 	;;
# 	u|update-apps)
# 		shift
# 		update_apps
# 	;;
# 	sk|set-keyboard)
# 		shift
# 		set_keyboard
# 	;;
# 	ef|expand-filesystem)
# 		shift
# 		expand_rootfs
# 	;;
# 	wf|wifi)
# 		shift
# 		"${DIRECTORY}/scripts/wifi" "$@" || exit 1
# 	;;
# 	*)
# 		pi-tools_help_ERROR_MESSAGE
# esac
#echo "$(echo "apt ($(apt list --installed  | grep -v Listing 2>/dev/null | wc -l))")$([ -a "$(command -v snap)" ] && if ! snap list 2>&1 | grep -q "No snaps are installed"; then echo " snap ($(snap list | tail -n +2 | wc -l))"; fi)$([ -a "$(command -v flatpak)" ] && if flatpak info 2>/dev/null | grep -q "Note that the directories"; then export XDG_DATA_DIRS="$XDG_DATA_DIRS:$(flatpak info 2>/dev/null | tail -n +4 | head -n 2 | x1s | sed 's/ /:/g')"; fi && [ "$(flatpak list)" != "" ] && echo " flatpak ($(flatpak list | grep -v "Application ID"  | wc -l))")"
